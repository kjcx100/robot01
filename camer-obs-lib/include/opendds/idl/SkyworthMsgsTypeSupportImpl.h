/* -*- C++ -*- */
/* Generated by opendds_idl version 3.13 (ACE version 6.2a_p15) running on input file SkyworthMsgs.idl */
#ifndef OPENDDS_IDL_GENERATED_SKYWORTHMSGSTYPESUPPORTIMPL_H_LXHU2G
#define OPENDDS_IDL_GENERATED_SKYWORTHMSGSTYPESUPPORTIMPL_H_LXHU2G
#include "SkyworthMsgsC.h"
#include "dds/DCPS/Definitions.h"
#include "dds/DdsDcpsC.h"
#include "SkyworthMsgsTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: SkyworthMsgs */



/* Begin STRUCT: EdgePolorPoint */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgePolorPoint& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgePolorPoint& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::EdgePolorPoint& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::EdgePolorPoint& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::EdgePolorPoint> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::EdgePolorPoint> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::EdgePolorPoint> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::EdgePolorPoint> stru);

template <>
struct MarshalTraits<SkyworthMsgs::EdgePolorPoint> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  EdgePolorPoint_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::EdgePolorPoint&, const SkyworthMsgs::EdgePolorPoint&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class EdgePolorPointTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::EdgePolorPoint> {
  typedef SkyworthMsgs::EdgePolorPoint MessageType;
  typedef SkyworthMsgs::EdgePolorPointSeq MessageSequenceType;
  typedef SkyworthMsgs::EdgePolorPointTypeSupport TypeSupportType;
  typedef SkyworthMsgs::EdgePolorPointTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::EdgePolorPointDataWriter DataWriterType;
  typedef SkyworthMsgs::EdgePolorPointDataReader DataReaderType;
  typedef SkyworthMsgs::EdgePolorPoint_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::EdgePolorPoint"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  EdgePolorPointTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<EdgePolorPointTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<EdgePolorPoint> TraitsType;
  typedef EdgePolorPointTypeSupport TypeSupportType;
  typedef EdgePolorPointTypeSupport::_var_type _var_type;
  typedef EdgePolorPointTypeSupport::_ptr_type _ptr_type;

  EdgePolorPointTypeSupportImpl() {}
  virtual ~EdgePolorPointTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static EdgePolorPointTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::EdgePolorPoint>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgePolorPoint*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EdgePolorPoint */


/* Begin STRUCT: EdgeXyzPoint */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgeXyzPoint& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgeXyzPoint& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::EdgeXyzPoint& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::EdgeXyzPoint& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::EdgeXyzPoint> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::EdgeXyzPoint> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::EdgeXyzPoint> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::EdgeXyzPoint> stru);

template <>
struct MarshalTraits<SkyworthMsgs::EdgeXyzPoint> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  EdgeXyzPoint_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::EdgeXyzPoint&, const SkyworthMsgs::EdgeXyzPoint&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class EdgeXyzPointTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::EdgeXyzPoint> {
  typedef SkyworthMsgs::EdgeXyzPoint MessageType;
  typedef SkyworthMsgs::EdgeXyzPointSeq MessageSequenceType;
  typedef SkyworthMsgs::EdgeXyzPointTypeSupport TypeSupportType;
  typedef SkyworthMsgs::EdgeXyzPointTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::EdgeXyzPointDataWriter DataWriterType;
  typedef SkyworthMsgs::EdgeXyzPointDataReader DataReaderType;
  typedef SkyworthMsgs::EdgeXyzPoint_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::EdgeXyzPoint"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  EdgeXyzPointTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<EdgeXyzPointTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<EdgeXyzPoint> TraitsType;
  typedef EdgeXyzPointTypeSupport TypeSupportType;
  typedef EdgeXyzPointTypeSupport::_var_type _var_type;
  typedef EdgeXyzPointTypeSupport::_ptr_type _ptr_type;

  EdgeXyzPointTypeSupportImpl() {}
  virtual ~EdgeXyzPointTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static EdgeXyzPointTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::EdgeXyzPoint>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgeXyzPoint*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EdgeXyzPoint */


/* Begin STRUCT: DestXyzPoint */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::DestXyzPoint& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::DestXyzPoint& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::DestXyzPoint& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::DestXyzPoint& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::DestXyzPoint> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::DestXyzPoint> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::DestXyzPoint> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::DestXyzPoint> stru);

template <>
struct MarshalTraits<SkyworthMsgs::DestXyzPoint> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  DestXyzPoint_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::DestXyzPoint&, const SkyworthMsgs::DestXyzPoint&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class DestXyzPointTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::DestXyzPoint> {
  typedef SkyworthMsgs::DestXyzPoint MessageType;
  typedef SkyworthMsgs::DestXyzPointSeq MessageSequenceType;
  typedef SkyworthMsgs::DestXyzPointTypeSupport TypeSupportType;
  typedef SkyworthMsgs::DestXyzPointTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::DestXyzPointDataWriter DataWriterType;
  typedef SkyworthMsgs::DestXyzPointDataReader DataReaderType;
  typedef SkyworthMsgs::DestXyzPoint_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::DestXyzPoint"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  DestXyzPointTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DestXyzPointTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<DestXyzPoint> TraitsType;
  typedef DestXyzPointTypeSupport TypeSupportType;
  typedef DestXyzPointTypeSupport::_var_type _var_type;
  typedef DestXyzPointTypeSupport::_ptr_type _ptr_type;

  DestXyzPointTypeSupportImpl() {}
  virtual ~DestXyzPointTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static DestXyzPointTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::DestXyzPoint>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::DestXyzPoint*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DestXyzPoint */


/* Begin TYPEDEF: EdgePolorPointList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgePolorPointList_forany& arr, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgePolorPointList_forany& arr);

bool operator>>(Serializer& strm, SkyworthMsgs::EdgePolorPointList_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgePolorPointList_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EdgePolorPointList */


/* Begin STRUCT: DepthEdgeData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::DepthEdgeData& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::DepthEdgeData& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::DepthEdgeData& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::DepthEdgeData& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::DepthEdgeData> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::DepthEdgeData> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::DepthEdgeData> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::DepthEdgeData> stru);

template <>
struct MarshalTraits<SkyworthMsgs::DepthEdgeData> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  DepthEdgeData_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::DepthEdgeData&, const SkyworthMsgs::DepthEdgeData&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class DepthEdgeDataTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::DepthEdgeData> {
  typedef SkyworthMsgs::DepthEdgeData MessageType;
  typedef SkyworthMsgs::DepthEdgeDataSeq MessageSequenceType;
  typedef SkyworthMsgs::DepthEdgeDataTypeSupport TypeSupportType;
  typedef SkyworthMsgs::DepthEdgeDataTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::DepthEdgeDataDataWriter DataWriterType;
  typedef SkyworthMsgs::DepthEdgeDataDataReader DataReaderType;
  typedef SkyworthMsgs::DepthEdgeData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::DepthEdgeData"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  DepthEdgeDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DepthEdgeDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<DepthEdgeData> TraitsType;
  typedef DepthEdgeDataTypeSupport TypeSupportType;
  typedef DepthEdgeDataTypeSupport::_var_type _var_type;
  typedef DepthEdgeDataTypeSupport::_ptr_type _ptr_type;

  DepthEdgeDataTypeSupportImpl() {}
  virtual ~DepthEdgeDataTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static DepthEdgeDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::DepthEdgeData>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::DepthEdgeData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DepthEdgeData */


/* Begin STRUCT: UltraTouchData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::UltraTouchData& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::UltraTouchData& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::UltraTouchData& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::UltraTouchData& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::UltraTouchData> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::UltraTouchData> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::UltraTouchData> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::UltraTouchData> stru);

template <>
struct MarshalTraits<SkyworthMsgs::UltraTouchData> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  UltraTouchData_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::UltraTouchData&, const SkyworthMsgs::UltraTouchData&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class UltraTouchDataTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::UltraTouchData> {
  typedef SkyworthMsgs::UltraTouchData MessageType;
  typedef SkyworthMsgs::UltraTouchDataSeq MessageSequenceType;
  typedef SkyworthMsgs::UltraTouchDataTypeSupport TypeSupportType;
  typedef SkyworthMsgs::UltraTouchDataTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::UltraTouchDataDataWriter DataWriterType;
  typedef SkyworthMsgs::UltraTouchDataDataReader DataReaderType;
  typedef SkyworthMsgs::UltraTouchData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::UltraTouchData"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  UltraTouchDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<UltraTouchDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<UltraTouchData> TraitsType;
  typedef UltraTouchDataTypeSupport TypeSupportType;
  typedef UltraTouchDataTypeSupport::_var_type _var_type;
  typedef UltraTouchDataTypeSupport::_ptr_type _ptr_type;

  UltraTouchDataTypeSupportImpl() {}
  virtual ~UltraTouchDataTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static UltraTouchDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::UltraTouchData>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::UltraTouchData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UltraTouchData */


/* Begin TYPEDEF: RgbPicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::RgbPicData_forany& arr, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::RgbPicData_forany& arr);

bool operator>>(Serializer& strm, SkyworthMsgs::RgbPicData_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::RgbPicData_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: RgbPicData */


/* Begin STRUCT: RgbPic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::RgbPic& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::RgbPic& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::RgbPic& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::RgbPic& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::RgbPic> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::RgbPic> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::RgbPic> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::RgbPic> stru);

template <>
struct MarshalTraits<SkyworthMsgs::RgbPic> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  RgbPic_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::RgbPic&, const SkyworthMsgs::RgbPic&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class RgbPicTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::RgbPic> {
  typedef SkyworthMsgs::RgbPic MessageType;
  typedef SkyworthMsgs::RgbPicSeq MessageSequenceType;
  typedef SkyworthMsgs::RgbPicTypeSupport TypeSupportType;
  typedef SkyworthMsgs::RgbPicTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::RgbPicDataWriter DataWriterType;
  typedef SkyworthMsgs::RgbPicDataReader DataReaderType;
  typedef SkyworthMsgs::RgbPic_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::RgbPic"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  RgbPicTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<RgbPicTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<RgbPic> TraitsType;
  typedef RgbPicTypeSupport TypeSupportType;
  typedef RgbPicTypeSupport::_var_type _var_type;
  typedef RgbPicTypeSupport::_ptr_type _ptr_type;

  RgbPicTypeSupportImpl() {}
  virtual ~RgbPicTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static RgbPicTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::RgbPic>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::RgbPic*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RgbPic */


/* Begin TYPEDEF: EdgeXyzPointList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgeXyzPointList_forany& arr, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgeXyzPointList_forany& arr);

bool operator>>(Serializer& strm, SkyworthMsgs::EdgeXyzPointList_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgeXyzPointList_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EdgeXyzPointList */


/* Begin STRUCT: ObsData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::ObsData& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::ObsData& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::ObsData& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::ObsData& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::ObsData> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::ObsData> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::ObsData> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::ObsData> stru);

template <>
struct MarshalTraits<SkyworthMsgs::ObsData> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  ObsData_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::ObsData&, const SkyworthMsgs::ObsData&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class ObsDataTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::ObsData> {
  typedef SkyworthMsgs::ObsData MessageType;
  typedef SkyworthMsgs::ObsDataSeq MessageSequenceType;
  typedef SkyworthMsgs::ObsDataTypeSupport TypeSupportType;
  typedef SkyworthMsgs::ObsDataTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::ObsDataDataWriter DataWriterType;
  typedef SkyworthMsgs::ObsDataDataReader DataReaderType;
  typedef SkyworthMsgs::ObsData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::ObsData"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  ObsDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ObsDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<ObsData> TraitsType;
  typedef ObsDataTypeSupport TypeSupportType;
  typedef ObsDataTypeSupport::_var_type _var_type;
  typedef ObsDataTypeSupport::_ptr_type _ptr_type;

  ObsDataTypeSupportImpl() {}
  virtual ~ObsDataTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static ObsDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::ObsData>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::ObsData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ObsData */


/* Begin STRUCT: CleanerStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanerStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanerStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanerStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanerStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanerStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanerStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanerStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanerStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanerStatus> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanerStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanerStatus&, const SkyworthMsgs::CleanerStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanerStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanerStatus> {
  typedef SkyworthMsgs::CleanerStatus MessageType;
  typedef SkyworthMsgs::CleanerStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanerStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanerStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanerStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanerStatusDataReader DataReaderType;
  typedef SkyworthMsgs::CleanerStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanerStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanerStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanerStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanerStatus> TraitsType;
  typedef CleanerStatusTypeSupport TypeSupportType;
  typedef CleanerStatusTypeSupport::_var_type _var_type;
  typedef CleanerStatusTypeSupport::_ptr_type _ptr_type;

  CleanerStatusTypeSupportImpl() {}
  virtual ~CleanerStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanerStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanerStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanerStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanerStatus */


/* Begin STRUCT: CleanerCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanerCommand& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanerCommand& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanerCommand& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanerCommand& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanerCommand> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanerCommand> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanerCommand> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanerCommand> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanerCommand> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanerCommand_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanerCommand&, const SkyworthMsgs::CleanerCommand&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanerCommandTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanerCommand> {
  typedef SkyworthMsgs::CleanerCommand MessageType;
  typedef SkyworthMsgs::CleanerCommandSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanerCommandTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanerCommandTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanerCommandDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanerCommandDataReader DataReaderType;
  typedef SkyworthMsgs::CleanerCommand_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanerCommand"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanerCommandTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanerCommandTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanerCommand> TraitsType;
  typedef CleanerCommandTypeSupport TypeSupportType;
  typedef CleanerCommandTypeSupport::_var_type _var_type;
  typedef CleanerCommandTypeSupport::_ptr_type _ptr_type;

  CleanerCommandTypeSupportImpl() {}
  virtual ~CleanerCommandTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanerCommandTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanerCommand>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanerCommand*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanerCommand */


/* Begin STRUCT: ElecQuantity */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::ElecQuantity& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::ElecQuantity& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::ElecQuantity& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::ElecQuantity& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::ElecQuantity> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::ElecQuantity> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::ElecQuantity> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::ElecQuantity> stru);

template <>
struct MarshalTraits<SkyworthMsgs::ElecQuantity> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  ElecQuantity_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::ElecQuantity&, const SkyworthMsgs::ElecQuantity&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class ElecQuantityTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::ElecQuantity> {
  typedef SkyworthMsgs::ElecQuantity MessageType;
  typedef SkyworthMsgs::ElecQuantitySeq MessageSequenceType;
  typedef SkyworthMsgs::ElecQuantityTypeSupport TypeSupportType;
  typedef SkyworthMsgs::ElecQuantityTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::ElecQuantityDataWriter DataWriterType;
  typedef SkyworthMsgs::ElecQuantityDataReader DataReaderType;
  typedef SkyworthMsgs::ElecQuantity_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::ElecQuantity"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  ElecQuantityTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ElecQuantityTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<ElecQuantity> TraitsType;
  typedef ElecQuantityTypeSupport TypeSupportType;
  typedef ElecQuantityTypeSupport::_var_type _var_type;
  typedef ElecQuantityTypeSupport::_ptr_type _ptr_type;

  ElecQuantityTypeSupportImpl() {}
  virtual ~ElecQuantityTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static ElecQuantityTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::ElecQuantity>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::ElecQuantity*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ElecQuantity */


/* Begin STRUCT: EmgStop */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EmgStop& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::EmgStop& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::EmgStop& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::EmgStop& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::EmgStop> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::EmgStop> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::EmgStop> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::EmgStop> stru);

template <>
struct MarshalTraits<SkyworthMsgs::EmgStop> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  EmgStop_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::EmgStop&, const SkyworthMsgs::EmgStop&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class EmgStopTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::EmgStop> {
  typedef SkyworthMsgs::EmgStop MessageType;
  typedef SkyworthMsgs::EmgStopSeq MessageSequenceType;
  typedef SkyworthMsgs::EmgStopTypeSupport TypeSupportType;
  typedef SkyworthMsgs::EmgStopTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::EmgStopDataWriter DataWriterType;
  typedef SkyworthMsgs::EmgStopDataReader DataReaderType;
  typedef SkyworthMsgs::EmgStop_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::EmgStop"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  EmgStopTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<EmgStopTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<EmgStop> TraitsType;
  typedef EmgStopTypeSupport TypeSupportType;
  typedef EmgStopTypeSupport::_var_type _var_type;
  typedef EmgStopTypeSupport::_ptr_type _ptr_type;

  EmgStopTypeSupportImpl() {}
  virtual ~EmgStopTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static EmgStopTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::EmgStop>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::EmgStop*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EmgStop */


/* Begin STRUCT: SlamStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::SlamStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::SlamStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  SlamStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::SlamStatus&, const SkyworthMsgs::SlamStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class SlamStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::SlamStatus> {
  typedef SkyworthMsgs::SlamStatus MessageType;
  typedef SkyworthMsgs::SlamStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::SlamStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::SlamStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::SlamStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::SlamStatusDataReader DataReaderType;
  typedef SkyworthMsgs::SlamStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::SlamStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  SlamStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SlamStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SlamStatus> TraitsType;
  typedef SlamStatusTypeSupport TypeSupportType;
  typedef SlamStatusTypeSupport::_var_type _var_type;
  typedef SlamStatusTypeSupport::_ptr_type _ptr_type;

  SlamStatusTypeSupportImpl() {}
  virtual ~SlamStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SlamStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamStatus */


/* Begin STRUCT: SlamCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamCommand& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamCommand& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::SlamCommand& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamCommand& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamCommand> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamCommand> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamCommand> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamCommand> stru);

template <>
struct MarshalTraits<SkyworthMsgs::SlamCommand> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  SlamCommand_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::SlamCommand&, const SkyworthMsgs::SlamCommand&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class SlamCommandTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::SlamCommand> {
  typedef SkyworthMsgs::SlamCommand MessageType;
  typedef SkyworthMsgs::SlamCommandSeq MessageSequenceType;
  typedef SkyworthMsgs::SlamCommandTypeSupport TypeSupportType;
  typedef SkyworthMsgs::SlamCommandTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::SlamCommandDataWriter DataWriterType;
  typedef SkyworthMsgs::SlamCommandDataReader DataReaderType;
  typedef SkyworthMsgs::SlamCommand_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::SlamCommand"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  SlamCommandTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SlamCommandTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SlamCommand> TraitsType;
  typedef SlamCommandTypeSupport TypeSupportType;
  typedef SlamCommandTypeSupport::_var_type _var_type;
  typedef SlamCommandTypeSupport::_ptr_type _ptr_type;

  SlamCommandTypeSupportImpl() {}
  virtual ~SlamCommandTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SlamCommandTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamCommand>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamCommand*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamCommand */


/* Begin STRUCT: SlamInteStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamInteStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamInteStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::SlamInteStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamInteStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamInteStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamInteStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamInteStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamInteStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::SlamInteStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  SlamInteStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::SlamInteStatus&, const SkyworthMsgs::SlamInteStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class SlamInteStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::SlamInteStatus> {
  typedef SkyworthMsgs::SlamInteStatus MessageType;
  typedef SkyworthMsgs::SlamInteStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::SlamInteStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::SlamInteStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::SlamInteStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::SlamInteStatusDataReader DataReaderType;
  typedef SkyworthMsgs::SlamInteStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::SlamInteStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  SlamInteStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SlamInteStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SlamInteStatus> TraitsType;
  typedef SlamInteStatusTypeSupport TypeSupportType;
  typedef SlamInteStatusTypeSupport::_var_type _var_type;
  typedef SlamInteStatusTypeSupport::_ptr_type _ptr_type;

  SlamInteStatusTypeSupportImpl() {}
  virtual ~SlamInteStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SlamInteStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamInteStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamInteStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamInteStatus */


/* Begin STRUCT: SlamInteCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamInteCommand& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamInteCommand& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::SlamInteCommand& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamInteCommand& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamInteCommand> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamInteCommand> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamInteCommand> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamInteCommand> stru);

template <>
struct MarshalTraits<SkyworthMsgs::SlamInteCommand> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  SlamInteCommand_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::SlamInteCommand&, const SkyworthMsgs::SlamInteCommand&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class SlamInteCommandTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::SlamInteCommand> {
  typedef SkyworthMsgs::SlamInteCommand MessageType;
  typedef SkyworthMsgs::SlamInteCommandSeq MessageSequenceType;
  typedef SkyworthMsgs::SlamInteCommandTypeSupport TypeSupportType;
  typedef SkyworthMsgs::SlamInteCommandTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::SlamInteCommandDataWriter DataWriterType;
  typedef SkyworthMsgs::SlamInteCommandDataReader DataReaderType;
  typedef SkyworthMsgs::SlamInteCommand_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::SlamInteCommand"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  SlamInteCommandTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SlamInteCommandTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SlamInteCommand> TraitsType;
  typedef SlamInteCommandTypeSupport TypeSupportType;
  typedef SlamInteCommandTypeSupport::_var_type _var_type;
  typedef SlamInteCommandTypeSupport::_ptr_type _ptr_type;

  SlamInteCommandTypeSupportImpl() {}
  virtual ~SlamInteCommandTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SlamInteCommandTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamInteCommand>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamInteCommand*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamInteCommand */


/* Begin STRUCT: PatrolStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::PatrolStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  PatrolStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::PatrolStatus&, const SkyworthMsgs::PatrolStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class PatrolStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::PatrolStatus> {
  typedef SkyworthMsgs::PatrolStatus MessageType;
  typedef SkyworthMsgs::PatrolStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::PatrolStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::PatrolStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::PatrolStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::PatrolStatusDataReader DataReaderType;
  typedef SkyworthMsgs::PatrolStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::PatrolStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  PatrolStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PatrolStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<PatrolStatus> TraitsType;
  typedef PatrolStatusTypeSupport TypeSupportType;
  typedef PatrolStatusTypeSupport::_var_type _var_type;
  typedef PatrolStatusTypeSupport::_ptr_type _ptr_type;

  PatrolStatusTypeSupportImpl() {}
  virtual ~PatrolStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static PatrolStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolStatus */


/* Begin STRUCT: PatrolCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolCommand& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolCommand& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolCommand& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolCommand& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolCommand> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolCommand> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolCommand> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolCommand> stru);

template <>
struct MarshalTraits<SkyworthMsgs::PatrolCommand> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  PatrolCommand_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::PatrolCommand&, const SkyworthMsgs::PatrolCommand&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class PatrolCommandTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::PatrolCommand> {
  typedef SkyworthMsgs::PatrolCommand MessageType;
  typedef SkyworthMsgs::PatrolCommandSeq MessageSequenceType;
  typedef SkyworthMsgs::PatrolCommandTypeSupport TypeSupportType;
  typedef SkyworthMsgs::PatrolCommandTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::PatrolCommandDataWriter DataWriterType;
  typedef SkyworthMsgs::PatrolCommandDataReader DataReaderType;
  typedef SkyworthMsgs::PatrolCommand_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::PatrolCommand"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  PatrolCommandTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PatrolCommandTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<PatrolCommand> TraitsType;
  typedef PatrolCommandTypeSupport TypeSupportType;
  typedef PatrolCommandTypeSupport::_var_type _var_type;
  typedef PatrolCommandTypeSupport::_ptr_type _ptr_type;

  PatrolCommandTypeSupportImpl() {}
  virtual ~PatrolCommandTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static PatrolCommandTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolCommand>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolCommand*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolCommand */


/* Begin STRUCT: CleanStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanStatus&, const SkyworthMsgs::CleanStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanStatus> {
  typedef SkyworthMsgs::CleanStatus MessageType;
  typedef SkyworthMsgs::CleanStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanStatusDataReader DataReaderType;
  typedef SkyworthMsgs::CleanStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanStatus> TraitsType;
  typedef CleanStatusTypeSupport TypeSupportType;
  typedef CleanStatusTypeSupport::_var_type _var_type;
  typedef CleanStatusTypeSupport::_ptr_type _ptr_type;

  CleanStatusTypeSupportImpl() {}
  virtual ~CleanStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanStatus */


/* Begin STRUCT: CleanCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanCommand& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanCommand& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanCommand& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanCommand& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanCommand> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanCommand> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanCommand> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanCommand> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanCommand> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanCommand_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanCommand&, const SkyworthMsgs::CleanCommand&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanCommandTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanCommand> {
  typedef SkyworthMsgs::CleanCommand MessageType;
  typedef SkyworthMsgs::CleanCommandSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanCommandTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanCommandTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanCommandDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanCommandDataReader DataReaderType;
  typedef SkyworthMsgs::CleanCommand_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanCommand"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanCommandTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanCommandTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanCommand> TraitsType;
  typedef CleanCommandTypeSupport TypeSupportType;
  typedef CleanCommandTypeSupport::_var_type _var_type;
  typedef CleanCommandTypeSupport::_ptr_type _ptr_type;

  CleanCommandTypeSupportImpl() {}
  virtual ~CleanCommandTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanCommandTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanCommand>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanCommand*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanCommand */


/* Begin TYPEDEF: MapPicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::MapPicData_forany& arr, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::MapPicData_forany& arr);

bool operator>>(Serializer& strm, SkyworthMsgs::MapPicData_forany& arr);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::MapPicData_forany*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: MapPicData */


/* Begin STRUCT: MapLiveData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::MapLiveData& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::MapLiveData& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::MapLiveData& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::MapLiveData& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::MapLiveData> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::MapLiveData> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::MapLiveData> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::MapLiveData> stru);

template <>
struct MarshalTraits<SkyworthMsgs::MapLiveData> {
  static bool gen_is_bounded_size() { return true; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  MapLiveData_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::MapLiveData&, const SkyworthMsgs::MapLiveData&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class MapLiveDataTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::MapLiveData> {
  typedef SkyworthMsgs::MapLiveData MessageType;
  typedef SkyworthMsgs::MapLiveDataSeq MessageSequenceType;
  typedef SkyworthMsgs::MapLiveDataTypeSupport TypeSupportType;
  typedef SkyworthMsgs::MapLiveDataTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::MapLiveDataDataWriter DataWriterType;
  typedef SkyworthMsgs::MapLiveDataDataReader DataReaderType;
  typedef SkyworthMsgs::MapLiveData_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::MapLiveData"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  MapLiveDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<MapLiveDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<MapLiveData> TraitsType;
  typedef MapLiveDataTypeSupport TypeSupportType;
  typedef MapLiveDataTypeSupport::_var_type _var_type;
  typedef MapLiveDataTypeSupport::_ptr_type _ptr_type;

  MapLiveDataTypeSupportImpl() {}
  virtual ~MapLiveDataTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static MapLiveDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::MapLiveData>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::MapLiveData*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: MapLiveData */


/* Begin STRUCT: SlamManageStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamManageStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamManageStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::SlamManageStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamManageStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamManageStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamManageStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamManageStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamManageStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::SlamManageStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  SlamManageStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::SlamManageStatus&, const SkyworthMsgs::SlamManageStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class SlamManageStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::SlamManageStatus> {
  typedef SkyworthMsgs::SlamManageStatus MessageType;
  typedef SkyworthMsgs::SlamManageStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::SlamManageStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::SlamManageStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::SlamManageStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::SlamManageStatusDataReader DataReaderType;
  typedef SkyworthMsgs::SlamManageStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::SlamManageStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  SlamManageStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SlamManageStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SlamManageStatus> TraitsType;
  typedef SlamManageStatusTypeSupport TypeSupportType;
  typedef SlamManageStatusTypeSupport::_var_type _var_type;
  typedef SlamManageStatusTypeSupport::_ptr_type _ptr_type;

  SlamManageStatusTypeSupportImpl() {}
  virtual ~SlamManageStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SlamManageStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamManageStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamManageStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamManageStatus */


/* Begin STRUCT: SlamManageCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamManageCmd& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamManageCmd& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::SlamManageCmd& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamManageCmd& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamManageCmd> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamManageCmd> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamManageCmd> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamManageCmd> stru);

template <>
struct MarshalTraits<SkyworthMsgs::SlamManageCmd> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  SlamManageCmd_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::SlamManageCmd&, const SkyworthMsgs::SlamManageCmd&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class SlamManageCmdTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::SlamManageCmd> {
  typedef SkyworthMsgs::SlamManageCmd MessageType;
  typedef SkyworthMsgs::SlamManageCmdSeq MessageSequenceType;
  typedef SkyworthMsgs::SlamManageCmdTypeSupport TypeSupportType;
  typedef SkyworthMsgs::SlamManageCmdTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::SlamManageCmdDataWriter DataWriterType;
  typedef SkyworthMsgs::SlamManageCmdDataReader DataReaderType;
  typedef SkyworthMsgs::SlamManageCmd_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::SlamManageCmd"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  SlamManageCmdTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SlamManageCmdTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<SlamManageCmd> TraitsType;
  typedef SlamManageCmdTypeSupport TypeSupportType;
  typedef SlamManageCmdTypeSupport::_var_type _var_type;
  typedef SlamManageCmdTypeSupport::_ptr_type _ptr_type;

  SlamManageCmdTypeSupportImpl() {}
  virtual ~SlamManageCmdTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static SlamManageCmdTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamManageCmd>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamManageCmd*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamManageCmd */


/* Begin STRUCT: PatrolManageStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolManageStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolManageStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolManageStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolManageStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolManageStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolManageStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolManageStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolManageStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::PatrolManageStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  PatrolManageStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::PatrolManageStatus&, const SkyworthMsgs::PatrolManageStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class PatrolManageStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::PatrolManageStatus> {
  typedef SkyworthMsgs::PatrolManageStatus MessageType;
  typedef SkyworthMsgs::PatrolManageStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::PatrolManageStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::PatrolManageStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::PatrolManageStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::PatrolManageStatusDataReader DataReaderType;
  typedef SkyworthMsgs::PatrolManageStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::PatrolManageStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  PatrolManageStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PatrolManageStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<PatrolManageStatus> TraitsType;
  typedef PatrolManageStatusTypeSupport TypeSupportType;
  typedef PatrolManageStatusTypeSupport::_var_type _var_type;
  typedef PatrolManageStatusTypeSupport::_ptr_type _ptr_type;

  PatrolManageStatusTypeSupportImpl() {}
  virtual ~PatrolManageStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static PatrolManageStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolManageStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolManageStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolManageStatus */


/* Begin STRUCT: PatrolManageCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolManageCmd& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolManageCmd& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolManageCmd& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolManageCmd& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolManageCmd> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolManageCmd> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolManageCmd> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolManageCmd> stru);

template <>
struct MarshalTraits<SkyworthMsgs::PatrolManageCmd> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  PatrolManageCmd_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::PatrolManageCmd&, const SkyworthMsgs::PatrolManageCmd&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class PatrolManageCmdTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::PatrolManageCmd> {
  typedef SkyworthMsgs::PatrolManageCmd MessageType;
  typedef SkyworthMsgs::PatrolManageCmdSeq MessageSequenceType;
  typedef SkyworthMsgs::PatrolManageCmdTypeSupport TypeSupportType;
  typedef SkyworthMsgs::PatrolManageCmdTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::PatrolManageCmdDataWriter DataWriterType;
  typedef SkyworthMsgs::PatrolManageCmdDataReader DataReaderType;
  typedef SkyworthMsgs::PatrolManageCmd_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::PatrolManageCmd"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  PatrolManageCmdTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PatrolManageCmdTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<PatrolManageCmd> TraitsType;
  typedef PatrolManageCmdTypeSupport TypeSupportType;
  typedef PatrolManageCmdTypeSupport::_var_type _var_type;
  typedef PatrolManageCmdTypeSupport::_ptr_type _ptr_type;

  PatrolManageCmdTypeSupportImpl() {}
  virtual ~PatrolManageCmdTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static PatrolManageCmdTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolManageCmd>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolManageCmd*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolManageCmd */


/* Begin STRUCT: CleanManageStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanManageStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanManageStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanManageStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanManageStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanManageStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanManageStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanManageStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanManageStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanManageStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanManageStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanManageStatus&, const SkyworthMsgs::CleanManageStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanManageStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanManageStatus> {
  typedef SkyworthMsgs::CleanManageStatus MessageType;
  typedef SkyworthMsgs::CleanManageStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanManageStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanManageStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanManageStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanManageStatusDataReader DataReaderType;
  typedef SkyworthMsgs::CleanManageStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanManageStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanManageStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanManageStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanManageStatus> TraitsType;
  typedef CleanManageStatusTypeSupport TypeSupportType;
  typedef CleanManageStatusTypeSupport::_var_type _var_type;
  typedef CleanManageStatusTypeSupport::_ptr_type _ptr_type;

  CleanManageStatusTypeSupportImpl() {}
  virtual ~CleanManageStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanManageStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanManageStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanManageStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanManageStatus */


/* Begin STRUCT: CleanManageCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanManageCmd& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanManageCmd& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanManageCmd& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanManageCmd& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanManageCmd> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanManageCmd> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanManageCmd> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanManageCmd> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanManageCmd> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanManageCmd_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanManageCmd&, const SkyworthMsgs::CleanManageCmd&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanManageCmdTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanManageCmd> {
  typedef SkyworthMsgs::CleanManageCmd MessageType;
  typedef SkyworthMsgs::CleanManageCmdSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanManageCmdTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanManageCmdTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanManageCmdDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanManageCmdDataReader DataReaderType;
  typedef SkyworthMsgs::CleanManageCmd_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanManageCmd"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanManageCmdTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanManageCmdTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanManageCmd> TraitsType;
  typedef CleanManageCmdTypeSupport TypeSupportType;
  typedef CleanManageCmdTypeSupport::_var_type _var_type;
  typedef CleanManageCmdTypeSupport::_ptr_type _ptr_type;

  CleanManageCmdTypeSupportImpl() {}
  virtual ~CleanManageCmdTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanManageCmdTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanManageCmd>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanManageCmd*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanManageCmd */


/* Begin STRUCT: MapLiveCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::MapLiveCmd& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::MapLiveCmd& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::MapLiveCmd& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::MapLiveCmd& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::MapLiveCmd> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::MapLiveCmd> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::MapLiveCmd> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::MapLiveCmd> stru);

template <>
struct MarshalTraits<SkyworthMsgs::MapLiveCmd> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  MapLiveCmd_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::MapLiveCmd&, const SkyworthMsgs::MapLiveCmd&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class MapLiveCmdTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::MapLiveCmd> {
  typedef SkyworthMsgs::MapLiveCmd MessageType;
  typedef SkyworthMsgs::MapLiveCmdSeq MessageSequenceType;
  typedef SkyworthMsgs::MapLiveCmdTypeSupport TypeSupportType;
  typedef SkyworthMsgs::MapLiveCmdTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::MapLiveCmdDataWriter DataWriterType;
  typedef SkyworthMsgs::MapLiveCmdDataReader DataReaderType;
  typedef SkyworthMsgs::MapLiveCmd_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::MapLiveCmd"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  MapLiveCmdTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<MapLiveCmdTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<MapLiveCmd> TraitsType;
  typedef MapLiveCmdTypeSupport TypeSupportType;
  typedef MapLiveCmdTypeSupport::_var_type _var_type;
  typedef MapLiveCmdTypeSupport::_ptr_type _ptr_type;

  MapLiveCmdTypeSupportImpl() {}
  virtual ~MapLiveCmdTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static MapLiveCmdTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::MapLiveCmd>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::MapLiveCmd*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: MapLiveCmd */


/* Begin STRUCT: CleanRouterStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanRouterStatus& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanRouterStatus& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanRouterStatus& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanRouterStatus& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanRouterStatus> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanRouterStatus> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanRouterStatus> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanRouterStatus> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanRouterStatus> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanRouterStatus_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanRouterStatus&, const SkyworthMsgs::CleanRouterStatus&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanRouterStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanRouterStatus> {
  typedef SkyworthMsgs::CleanRouterStatus MessageType;
  typedef SkyworthMsgs::CleanRouterStatusSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanRouterStatusTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanRouterStatusTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanRouterStatusDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanRouterStatusDataReader DataReaderType;
  typedef SkyworthMsgs::CleanRouterStatus_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanRouterStatus"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanRouterStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanRouterStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanRouterStatus> TraitsType;
  typedef CleanRouterStatusTypeSupport TypeSupportType;
  typedef CleanRouterStatusTypeSupport::_var_type _var_type;
  typedef CleanRouterStatusTypeSupport::_ptr_type _ptr_type;

  CleanRouterStatusTypeSupportImpl() {}
  virtual ~CleanRouterStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanRouterStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanRouterStatus>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanRouterStatus*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanRouterStatus */


/* Begin STRUCT: CleanRouterCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanRouterCmd& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanRouterCmd& stru);

bool operator>>(Serializer& strm, SkyworthMsgs::CleanRouterCmd& stru);

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanRouterCmd& stru, bool align);

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanRouterCmd> stru, bool align);

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanRouterCmd> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanRouterCmd> stru);

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanRouterCmd> stru);

template <>
struct MarshalTraits<SkyworthMsgs::CleanRouterCmd> {
  static bool gen_is_bounded_size() { return false; }
  static bool gen_is_bounded_key_size() { return true; }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  CleanRouterCmd_OpenDDS_KeyLessThan {
  bool operator()(const SkyworthMsgs::CleanRouterCmd&, const SkyworthMsgs::CleanRouterCmd&) const
  {
    // Eith no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}


namespace SkyworthMsgs {
class CleanRouterCmdTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {
template <>
struct DDSTraits<SkyworthMsgs::CleanRouterCmd> {
  typedef SkyworthMsgs::CleanRouterCmd MessageType;
  typedef SkyworthMsgs::CleanRouterCmdSeq MessageSequenceType;
  typedef SkyworthMsgs::CleanRouterCmdTypeSupport TypeSupportType;
  typedef SkyworthMsgs::CleanRouterCmdTypeSupportImpl TypeSupportTypeImpl;
  typedef SkyworthMsgs::CleanRouterCmdDataWriter DataWriterType;
  typedef SkyworthMsgs::CleanRouterCmdDataReader DataReaderType;
  typedef SkyworthMsgs::CleanRouterCmd_OpenDDS_KeyLessThan LessThanType;

  static const char* type_name () { return "SkyworthMsgs::CleanRouterCmd"; }
  static bool gen_has_key () { return false; }

  static size_t gen_max_marshaled_size(const MessageType& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const MessageType& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }

  static size_t gen_max_marshaled_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& x, bool align) { return ::OpenDDS::DCPS::gen_max_marshaled_size(x, align); }
  static void gen_find_size(const OpenDDS::DCPS::KeyOnly<const MessageType>& arr, size_t& size, size_t& padding) { ::OpenDDS::DCPS::gen_find_size(arr, size, padding); }
};
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
class  CleanRouterCmdTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<CleanRouterCmdTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<CleanRouterCmd> TraitsType;
  typedef CleanRouterCmdTypeSupport TypeSupportType;
  typedef CleanRouterCmdTypeSupport::_var_type _var_type;
  typedef CleanRouterCmdTypeSupport::_ptr_type _ptr_type;

  CleanRouterCmdTypeSupportImpl() {}
  virtual ~CleanRouterCmdTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;
  static CleanRouterCmdTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanRouterCmd>();
bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanRouterCmd*);

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanRouterCmd */

/* End MODULE: SkyworthMsgs */
#endif /* OPENDDS_IDL_GENERATED_SKYWORTHMSGSTYPESUPPORTIMPL_H_LXHU2G */
