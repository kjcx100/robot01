/* Generated by opendds_idl version 3.13 (ACE version 6.2a_p15) running on input file SkyworthMsgs.idl */
#include "SkyworthMsgsTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: SkyworthMsgs */



/* Begin STRUCT: EdgePolorPoint */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgePolorPoint& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.angle);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.distance);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgePolorPoint& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.angle)
    && (strm << stru.distance);
}

bool operator>>(Serializer& strm, SkyworthMsgs::EdgePolorPoint& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.angle)
    && (strm >> stru.distance);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::EdgePolorPoint& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 8;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::EdgePolorPoint> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::EdgePolorPoint> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::EdgePolorPoint> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::EdgePolorPoint> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr EdgePolorPointTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<EdgePolorPoint> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr EdgePolorPointTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<EdgePolorPoint> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr EdgePolorPointTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<EdgePolorPoint> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<EdgePolorPoint, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& EdgePolorPointTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<EdgePolorPoint>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool EdgePolorPointTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* EdgePolorPointTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

EdgePolorPointTypeSupport::_ptr_type EdgePolorPointTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::EdgePolorPoint> : MetaStruct {
  typedef SkyworthMsgs::EdgePolorPoint T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::EdgePolorPoint& typed = *static_cast<const SkyworthMsgs::EdgePolorPoint*>(stru);
    if (std::strcmp(field, "angle") == 0) {
      return typed.angle;
    }
    if (std::strcmp(field, "distance") == 0) {
      return typed.distance;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgePolorPoint)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "angle") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'angle' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'angle' could not be skipped");
      }
    }
    if (std::strcmp(field, "distance") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'distance' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'distance' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::EdgePolorPoint");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "angle") == 0) {
      return make_field_cmp(&T::angle, next);
    }
    if (std::strcmp(field, "distance") == 0) {
      return make_field_cmp(&T::distance, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgePolorPoint)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"angle", "distance", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "angle") == 0) {
      return &static_cast<const T*>(stru)->angle;
    }
    if (std::strcmp(field, "distance") == 0) {
      return &static_cast<const T*>(stru)->distance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgePolorPoint)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "angle") == 0) {
      static_cast<T*>(lhs)->angle = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "distance") == 0) {
      static_cast<T*>(lhs)->distance = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgePolorPoint)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "angle") == 0) {
      return static_cast<const T*>(lhs)->angle == static_cast<const T*>(rhs)->angle;
    }
    if (std::strcmp(field, "distance") == 0) {
      return static_cast<const T*>(lhs)->distance == static_cast<const T*>(rhs)->distance;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgePolorPoint)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::EdgePolorPoint>()
{
  static MetaStructImpl<SkyworthMsgs::EdgePolorPoint> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgePolorPoint*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::EdgePolorPoint>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EdgePolorPoint */


/* Begin STRUCT: EdgeXyzPoint */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgeXyzPoint& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.y);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.z);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgeXyzPoint& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.x)
    && (strm << stru.y)
    && (strm << stru.z);
}

bool operator>>(Serializer& strm, SkyworthMsgs::EdgeXyzPoint& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.x)
    && (strm >> stru.y)
    && (strm >> stru.z);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::EdgeXyzPoint& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 12;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::EdgeXyzPoint> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::EdgeXyzPoint> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::EdgeXyzPoint> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::EdgeXyzPoint> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr EdgeXyzPointTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<EdgeXyzPoint> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr EdgeXyzPointTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<EdgeXyzPoint> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr EdgeXyzPointTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<EdgeXyzPoint> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<EdgeXyzPoint, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& EdgeXyzPointTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<EdgeXyzPoint>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool EdgeXyzPointTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* EdgeXyzPointTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

EdgeXyzPointTypeSupport::_ptr_type EdgeXyzPointTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::EdgeXyzPoint> : MetaStruct {
  typedef SkyworthMsgs::EdgeXyzPoint T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::EdgeXyzPoint& typed = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(stru);
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    if (std::strcmp(field, "z") == 0) {
      return typed.z;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgeXyzPoint)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "x") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'x' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'x' could not be skipped");
      }
    }
    if (std::strcmp(field, "y") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'y' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'y' could not be skipped");
      }
    }
    if (std::strcmp(field, "z") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'z' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'z' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::EdgeXyzPoint");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    if (std::strcmp(field, "z") == 0) {
      return make_field_cmp(&T::z, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgeXyzPoint)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"x", "y", "z", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    if (std::strcmp(field, "z") == 0) {
      return &static_cast<const T*>(stru)->z;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgeXyzPoint)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "z") == 0) {
      static_cast<T*>(lhs)->z = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgeXyzPoint)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    if (std::strcmp(field, "z") == 0) {
      return static_cast<const T*>(lhs)->z == static_cast<const T*>(rhs)->z;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EdgeXyzPoint)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::EdgeXyzPoint>()
{
  static MetaStructImpl<SkyworthMsgs::EdgeXyzPoint> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgeXyzPoint*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EdgeXyzPoint */


/* Begin STRUCT: DestXyzPoint */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::DestXyzPoint& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.y);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.z);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.angle);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::DestXyzPoint& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.x)
    && (strm << stru.y)
    && (strm << stru.z)
    && (strm << stru.angle);
}

bool operator>>(Serializer& strm, SkyworthMsgs::DestXyzPoint& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.x)
    && (strm >> stru.y)
    && (strm >> stru.z)
    && (strm >> stru.angle);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::DestXyzPoint& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 16;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::DestXyzPoint> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::DestXyzPoint> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::DestXyzPoint> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::DestXyzPoint> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr DestXyzPointTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DestXyzPoint> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr DestXyzPointTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DestXyzPoint> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DestXyzPointTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DestXyzPoint> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DestXyzPoint, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DestXyzPointTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DestXyzPoint>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool DestXyzPointTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* DestXyzPointTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

DestXyzPointTypeSupport::_ptr_type DestXyzPointTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::DestXyzPoint> : MetaStruct {
  typedef SkyworthMsgs::DestXyzPoint T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::DestXyzPoint& typed = *static_cast<const SkyworthMsgs::DestXyzPoint*>(stru);
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    if (std::strcmp(field, "z") == 0) {
      return typed.z;
    }
    if (std::strcmp(field, "angle") == 0) {
      return typed.angle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DestXyzPoint)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "x") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'x' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'x' could not be skipped");
      }
    }
    if (std::strcmp(field, "y") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'y' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'y' could not be skipped");
      }
    }
    if (std::strcmp(field, "z") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'z' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'z' could not be skipped");
      }
    }
    if (std::strcmp(field, "angle") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'angle' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'angle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::DestXyzPoint");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    if (std::strcmp(field, "z") == 0) {
      return make_field_cmp(&T::z, next);
    }
    if (std::strcmp(field, "angle") == 0) {
      return make_field_cmp(&T::angle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DestXyzPoint)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"x", "y", "z", "angle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    if (std::strcmp(field, "z") == 0) {
      return &static_cast<const T*>(stru)->z;
    }
    if (std::strcmp(field, "angle") == 0) {
      return &static_cast<const T*>(stru)->angle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DestXyzPoint)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "z") == 0) {
      static_cast<T*>(lhs)->z = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "angle") == 0) {
      static_cast<T*>(lhs)->angle = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DestXyzPoint)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    if (std::strcmp(field, "z") == 0) {
      return static_cast<const T*>(lhs)->z == static_cast<const T*>(rhs)->z;
    }
    if (std::strcmp(field, "angle") == 0) {
      return static_cast<const T*>(lhs)->angle == static_cast<const T*>(rhs)->angle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DestXyzPoint)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::DestXyzPoint>()
{
  static MetaStructImpl<SkyworthMsgs::DestXyzPoint> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::DestXyzPoint*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::DestXyzPoint>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DestXyzPoint */


/* Begin TYPEDEF: EdgePolorPointList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgePolorPointList_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgePolorPointList_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, SkyworthMsgs::EdgePolorPointList_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgePolorPointList_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 360; ++i) {
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgePolorPoint*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EdgePolorPointList */


/* Begin STRUCT: DepthEdgeData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::DepthEdgeData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  SkyworthMsgs::EdgePolorPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgePolorPointList_slice*>(stru.pointList));
  gen_find_size(stru_pointList, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::DepthEdgeData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgePolorPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgePolorPointList_slice*>(stru.pointList));
  return (strm << stru_pointList);
}

bool operator>>(Serializer& strm, SkyworthMsgs::DepthEdgeData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgePolorPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgePolorPointList_slice*>(stru.pointList));
  return (strm >> stru_pointList);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::DepthEdgeData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 2880;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::DepthEdgeData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::DepthEdgeData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::DepthEdgeData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::DepthEdgeData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr DepthEdgeDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<DepthEdgeData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr DepthEdgeDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DepthEdgeData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr DepthEdgeDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<DepthEdgeData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<DepthEdgeData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& DepthEdgeDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<DepthEdgeData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool DepthEdgeDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* DepthEdgeDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

DepthEdgeDataTypeSupport::_ptr_type DepthEdgeDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::DepthEdgeData> : MetaStruct {
  typedef SkyworthMsgs::DepthEdgeData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::DepthEdgeData& typed = *static_cast<const SkyworthMsgs::DepthEdgeData*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DepthEdgeData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgePolorPointList_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::DepthEdgeData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DepthEdgeData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"pointList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "pointList") == 0) {
      return &static_cast<const T*>(stru)->pointList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DepthEdgeData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "pointList") == 0) {
      SkyworthMsgs::EdgePolorPointList* lhsArr = &static_cast<T*>(lhs)->pointList;
      const SkyworthMsgs::EdgePolorPointList* rhsArr = static_cast<const SkyworthMsgs::EdgePolorPointList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DepthEdgeData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::DepthEdgeData)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::DepthEdgeData>()
{
  static MetaStructImpl<SkyworthMsgs::DepthEdgeData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::DepthEdgeData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::DepthEdgeData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DepthEdgeData */


/* Begin STRUCT: UltraTouchData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::UltraTouchData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  SkyworthMsgs::EdgePolorPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgePolorPointList_slice*>(stru.pointList));
  gen_find_size(stru_pointList, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::UltraTouchData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgePolorPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgePolorPointList_slice*>(stru.pointList));
  return (strm << stru_pointList);
}

bool operator>>(Serializer& strm, SkyworthMsgs::UltraTouchData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgePolorPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgePolorPointList_slice*>(stru.pointList));
  return (strm >> stru_pointList);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::UltraTouchData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 2880;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::UltraTouchData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::UltraTouchData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::UltraTouchData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::UltraTouchData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr UltraTouchDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<UltraTouchData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr UltraTouchDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<UltraTouchData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr UltraTouchDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<UltraTouchData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<UltraTouchData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& UltraTouchDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<UltraTouchData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool UltraTouchDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* UltraTouchDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

UltraTouchDataTypeSupport::_ptr_type UltraTouchDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::UltraTouchData> : MetaStruct {
  typedef SkyworthMsgs::UltraTouchData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::UltraTouchData& typed = *static_cast<const SkyworthMsgs::UltraTouchData*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::UltraTouchData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgePolorPointList_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::UltraTouchData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::UltraTouchData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"pointList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "pointList") == 0) {
      return &static_cast<const T*>(stru)->pointList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::UltraTouchData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "pointList") == 0) {
      SkyworthMsgs::EdgePolorPointList* lhsArr = &static_cast<T*>(lhs)->pointList;
      const SkyworthMsgs::EdgePolorPointList* rhsArr = static_cast<const SkyworthMsgs::EdgePolorPointList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::UltraTouchData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::UltraTouchData)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::UltraTouchData>()
{
  static MetaStructImpl<SkyworthMsgs::UltraTouchData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::UltraTouchData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::UltraTouchData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UltraTouchData */


/* Begin TYPEDEF: RgbPicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::RgbPicData_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 230400 * max_marshaled_size_char();
}

bool operator<<(Serializer& strm, const SkyworthMsgs::RgbPicData_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_char_array(arr.in(), 230400);
}

bool operator>>(Serializer& strm, SkyworthMsgs::RgbPicData_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_char_array(arr.out(), 230400);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::RgbPicData_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(230400), 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: RgbPicData */


/* Begin STRUCT: RgbPic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::RgbPic& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  SkyworthMsgs::RgbPicData_forany stru_data(const_cast<SkyworthMsgs::RgbPicData_slice*>(stru.data));
  gen_find_size(stru_data, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::RgbPic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::RgbPicData_forany stru_data(const_cast<SkyworthMsgs::RgbPicData_slice*>(stru.data));
  return (strm << stru_data);
}

bool operator>>(Serializer& strm, SkyworthMsgs::RgbPic& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::RgbPicData_forany stru_data(const_cast<SkyworthMsgs::RgbPicData_slice*>(stru.data));
  return (strm >> stru_data);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::RgbPic& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 230400;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::RgbPic> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::RgbPic> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::RgbPic> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::RgbPic> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr RgbPicTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<RgbPic> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr RgbPicTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RgbPic> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr RgbPicTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<RgbPic> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<RgbPic, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& RgbPicTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<RgbPic>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool RgbPicTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* RgbPicTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

RgbPicTypeSupport::_ptr_type RgbPicTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::RgbPic> : MetaStruct {
  typedef SkyworthMsgs::RgbPic T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::RgbPic& typed = *static_cast<const SkyworthMsgs::RgbPic*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::RgbPic)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::RgbPicData_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::RgbPic");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::RgbPic)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::RgbPic)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "data") == 0) {
      SkyworthMsgs::RgbPicData* lhsArr = &static_cast<T*>(lhs)->data;
      const SkyworthMsgs::RgbPicData* rhsArr = static_cast<const SkyworthMsgs::RgbPicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 230400; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::RgbPic)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::RgbPic)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::RgbPic>()
{
  static MetaStructImpl<SkyworthMsgs::RgbPic> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::RgbPic*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::RgbPic>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RgbPic */


/* Begin TYPEDEF: EdgeXyzPointList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EdgeXyzPointList_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const SkyworthMsgs::EdgeXyzPointList_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, SkyworthMsgs::EdgeXyzPointList_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::EdgeXyzPointList_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 360; ++i) {
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EdgeXyzPointList */


/* Begin STRUCT: ObsData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::ObsData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  SkyworthMsgs::EdgeXyzPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgeXyzPointList_slice*>(stru.pointList));
  gen_find_size(stru_pointList, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::ObsData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgeXyzPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgeXyzPointList_slice*>(stru.pointList));
  return (strm << stru_pointList);
}

bool operator>>(Serializer& strm, SkyworthMsgs::ObsData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgeXyzPointList_forany stru_pointList(const_cast<SkyworthMsgs::EdgeXyzPointList_slice*>(stru.pointList));
  return (strm >> stru_pointList);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::ObsData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 4320;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::ObsData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::ObsData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::ObsData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::ObsData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr ObsDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ObsData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr ObsDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ObsData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ObsDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ObsData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ObsData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ObsDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ObsData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool ObsDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* ObsDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

ObsDataTypeSupport::_ptr_type ObsDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::ObsData> : MetaStruct {
  typedef SkyworthMsgs::ObsData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::ObsData& typed = *static_cast<const SkyworthMsgs::ObsData*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ObsData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPointList_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::ObsData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ObsData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"pointList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "pointList") == 0) {
      return &static_cast<const T*>(stru)->pointList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ObsData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "pointList") == 0) {
      SkyworthMsgs::EdgeXyzPointList* lhsArr = &static_cast<T*>(lhs)->pointList;
      const SkyworthMsgs::EdgeXyzPointList* rhsArr = static_cast<const SkyworthMsgs::EdgeXyzPointList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ObsData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ObsData)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::ObsData>()
{
  static MetaStructImpl<SkyworthMsgs::ObsData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::ObsData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::ObsData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ObsData */


/* Begin STRUCT: CleanerStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanerStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.status);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanerStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.status);
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanerStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.status);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanerStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 2;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanerStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanerStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanerStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanerStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanerStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanerStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanerStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanerStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanerStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanerStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanerStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanerStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanerStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanerStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanerStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanerStatusTypeSupport::_ptr_type CleanerStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanerStatus> : MetaStruct {
  typedef SkyworthMsgs::CleanerStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanerStatus& typed = *static_cast<const SkyworthMsgs::CleanerStatus*>(stru);
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Short val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanerStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Short*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanerStatus>()
{
  static MetaStructImpl<SkyworthMsgs::CleanerStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanerStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanerStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanerStatus */


/* Begin STRUCT: CleanerCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanerCommand& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.cleanType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.cleanCommand));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanerCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.cleanType.in())
    && (strm << ACE_OutputCDR::from_char(stru.cleanCommand));
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanerCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.cleanType.out())
    && (strm >> ACE_InputCDR::to_char(stru.cleanCommand));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanerCommand& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanerCommand> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanerCommand> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanerCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanerCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanerCommandTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanerCommand> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanerCommandTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanerCommand> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanerCommandTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanerCommand> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanerCommand, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanerCommandTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanerCommand>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanerCommandTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanerCommandTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanerCommandTypeSupport::_ptr_type CleanerCommandTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanerCommand> : MetaStruct {
  typedef SkyworthMsgs::CleanerCommand T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanerCommand& typed = *static_cast<const SkyworthMsgs::CleanerCommand*>(stru);
    if (std::strcmp(field, "cleanType") == 0) {
      return typed.cleanType.in();
    }
    if (std::strcmp(field, "cleanCommand") == 0) {
      return typed.cleanCommand;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerCommand)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "cleanType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'cleanType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'cleanType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'cleanType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "cleanCommand") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'cleanCommand' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'cleanCommand' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanerCommand");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "cleanType") == 0) {
      return make_field_cmp(&T::cleanType, next);
    }
    if (std::strcmp(field, "cleanCommand") == 0) {
      return make_field_cmp(&T::cleanCommand, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerCommand)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"cleanType", "cleanCommand", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "cleanType") == 0) {
      return &static_cast<const T*>(stru)->cleanType;
    }
    if (std::strcmp(field, "cleanCommand") == 0) {
      return &static_cast<const T*>(stru)->cleanCommand;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerCommand)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "cleanType") == 0) {
      static_cast<T*>(lhs)->cleanType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "cleanCommand") == 0) {
      static_cast<T*>(lhs)->cleanCommand = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerCommand)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "cleanType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->cleanType.in(), static_cast<const T*>(rhs)->cleanType.in());
    }
    if (std::strcmp(field, "cleanCommand") == 0) {
      return static_cast<const T*>(lhs)->cleanCommand == static_cast<const T*>(rhs)->cleanCommand;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanerCommand)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanerCommand>()
{
  static MetaStructImpl<SkyworthMsgs::CleanerCommand> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanerCommand*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanerCommand>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanerCommand */


/* Begin STRUCT: ElecQuantity */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::ElecQuantity& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.batteryType.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.quantity);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::ElecQuantity& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.batteryType.in())
    && (strm << stru.quantity);
}

bool operator>>(Serializer& strm, SkyworthMsgs::ElecQuantity& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.batteryType.out())
    && (strm >> stru.quantity);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::ElecQuantity& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::ElecQuantity> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::ElecQuantity> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::ElecQuantity> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::ElecQuantity> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr ElecQuantityTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<ElecQuantity> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr ElecQuantityTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ElecQuantity> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr ElecQuantityTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<ElecQuantity> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ElecQuantity, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& ElecQuantityTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<ElecQuantity>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool ElecQuantityTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* ElecQuantityTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

ElecQuantityTypeSupport::_ptr_type ElecQuantityTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::ElecQuantity> : MetaStruct {
  typedef SkyworthMsgs::ElecQuantity T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::ElecQuantity& typed = *static_cast<const SkyworthMsgs::ElecQuantity*>(stru);
    if (std::strcmp(field, "batteryType") == 0) {
      return typed.batteryType.in();
    }
    if (std::strcmp(field, "quantity") == 0) {
      return typed.quantity;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ElecQuantity)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "batteryType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'batteryType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'batteryType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'batteryType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "quantity") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'quantity' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'quantity' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::ElecQuantity");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "batteryType") == 0) {
      return make_field_cmp(&T::batteryType, next);
    }
    if (std::strcmp(field, "quantity") == 0) {
      return make_field_cmp(&T::quantity, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ElecQuantity)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"batteryType", "quantity", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "batteryType") == 0) {
      return &static_cast<const T*>(stru)->batteryType;
    }
    if (std::strcmp(field, "quantity") == 0) {
      return &static_cast<const T*>(stru)->quantity;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ElecQuantity)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "batteryType") == 0) {
      static_cast<T*>(lhs)->batteryType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "quantity") == 0) {
      static_cast<T*>(lhs)->quantity = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ElecQuantity)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "batteryType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->batteryType.in(), static_cast<const T*>(rhs)->batteryType.in());
    }
    if (std::strcmp(field, "quantity") == 0) {
      return static_cast<const T*>(lhs)->quantity == static_cast<const T*>(rhs)->quantity;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::ElecQuantity)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::ElecQuantity>()
{
  static MetaStructImpl<SkyworthMsgs::ElecQuantity> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::ElecQuantity*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::ElecQuantity>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ElecQuantity */


/* Begin STRUCT: EmgStop */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::EmgStop& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.emgStopCommand));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::EmgStop& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_char(stru.emgStopCommand));
}

bool operator>>(Serializer& strm, SkyworthMsgs::EmgStop& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_char(stru.emgStopCommand));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::EmgStop& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 1;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::EmgStop> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::EmgStop> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::EmgStop> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::EmgStop> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr EmgStopTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<EmgStop> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr EmgStopTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<EmgStop> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr EmgStopTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<EmgStop> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<EmgStop, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& EmgStopTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<EmgStop>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool EmgStopTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* EmgStopTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

EmgStopTypeSupport::_ptr_type EmgStopTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::EmgStop> : MetaStruct {
  typedef SkyworthMsgs::EmgStop T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::EmgStop& typed = *static_cast<const SkyworthMsgs::EmgStop*>(stru);
    if (std::strcmp(field, "emgStopCommand") == 0) {
      return typed.emgStopCommand;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EmgStop)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "emgStopCommand") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'emgStopCommand' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'emgStopCommand' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::EmgStop");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "emgStopCommand") == 0) {
      return make_field_cmp(&T::emgStopCommand, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EmgStop)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"emgStopCommand", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "emgStopCommand") == 0) {
      return &static_cast<const T*>(stru)->emgStopCommand;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EmgStop)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "emgStopCommand") == 0) {
      static_cast<T*>(lhs)->emgStopCommand = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EmgStop)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "emgStopCommand") == 0) {
      return static_cast<const T*>(lhs)->emgStopCommand == static_cast<const T*>(rhs)->emgStopCommand;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::EmgStop)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::EmgStop>()
{
  static MetaStructImpl<SkyworthMsgs::EmgStop> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::EmgStop*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::EmgStop>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EmgStop */


/* Begin STRUCT: SlamStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.status);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.statusType.in())
    && (strm << stru.status);
}

bool operator>>(Serializer& strm, SkyworthMsgs::SlamStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.statusType.out())
    && (strm >> stru.status);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr SlamStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SlamStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SlamStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SlamStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SlamStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SlamStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SlamStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SlamStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* SlamStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

SlamStatusTypeSupport::_ptr_type SlamStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::SlamStatus> : MetaStruct {
  typedef SkyworthMsgs::SlamStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::SlamStatus& typed = *static_cast<const SkyworthMsgs::SlamStatus*>(stru);
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Short val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::SlamStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"statusType", "status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Short*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamStatus>()
{
  static MetaStructImpl<SkyworthMsgs::SlamStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::SlamStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamStatus */


/* Begin STRUCT: SlamCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamCommand& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.distance);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.angle);
  gen_find_size(stru.destPoint, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command))
    && (strm << stru.distance)
    && (strm << stru.angle)
    && (strm << stru.destPoint);
}

bool operator>>(Serializer& strm, SkyworthMsgs::SlamCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command))
    && (strm >> stru.distance)
    && (strm >> stru.angle)
    && (strm >> stru.destPoint);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamCommand& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamCommand> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamCommand> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr SlamCommandTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SlamCommand> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SlamCommandTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamCommand> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SlamCommandTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamCommand> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SlamCommand, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SlamCommandTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SlamCommand>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SlamCommandTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* SlamCommandTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

SlamCommandTypeSupport::_ptr_type SlamCommandTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::SlamCommand> : MetaStruct {
  typedef SkyworthMsgs::SlamCommand T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::SlamCommand& typed = *static_cast<const SkyworthMsgs::SlamCommand*>(stru);
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return typed.distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return typed.angle;
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(&typed.destPoint, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamCommand)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (std::strcmp(field, "distance") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'distance' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'distance' could not be skipped");
      }
    }
    if (std::strcmp(field, "angle") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'angle' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'angle' could not be skipped");
      }
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(ser, field + 10);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::DestXyzPoint*>(0))) {
        throw std::runtime_error("Field 'destPoint' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::SlamCommand");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    if (std::strcmp(field, "distance") == 0) {
      return make_field_cmp(&T::distance, next);
    }
    if (std::strcmp(field, "angle") == 0) {
      return make_field_cmp(&T::angle, next);
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return make_struct_cmp(&T::destPoint, getMetaStruct<SkyworthMsgs::DestXyzPoint>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamCommand)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"commandType", "command", "distance", "angle", "destPoint", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return &static_cast<const T*>(stru)->distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return &static_cast<const T*>(stru)->angle;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      return &static_cast<const T*>(stru)->destPoint;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamCommand)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "distance") == 0) {
      static_cast<T*>(lhs)->distance = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "angle") == 0) {
      static_cast<T*>(lhs)->angle = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      static_cast<T*>(lhs)->destPoint = *static_cast<const SkyworthMsgs::DestXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamCommand)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return static_cast<const T*>(lhs)->distance == static_cast<const T*>(rhs)->distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return static_cast<const T*>(lhs)->angle == static_cast<const T*>(rhs)->angle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamCommand)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamCommand>()
{
  static MetaStructImpl<SkyworthMsgs::SlamCommand> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamCommand*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::SlamCommand>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamCommand */


/* Begin STRUCT: SlamInteStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamInteStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  SkyworthMsgs::EdgeXyzPointList_forany stru_obsData(const_cast<SkyworthMsgs::EdgeXyzPointList_slice*>(stru.obsData));
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.status));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.machingDegree);
  gen_find_size(stru_obsData, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamInteStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgeXyzPointList_forany stru_obsData(const_cast<SkyworthMsgs::EdgeXyzPointList_slice*>(stru.obsData));
  return (strm << stru.statusType.in())
    && (strm << ACE_OutputCDR::from_char(stru.status))
    && (strm << stru.machingDegree)
    && (strm << stru_obsData);
}

bool operator>>(Serializer& strm, SkyworthMsgs::SlamInteStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::EdgeXyzPointList_forany stru_obsData(const_cast<SkyworthMsgs::EdgeXyzPointList_slice*>(stru.obsData));
  return (strm >> stru.statusType.out())
    && (strm >> ACE_InputCDR::to_char(stru.status))
    && (strm >> stru.machingDegree)
    && (strm >> stru_obsData);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamInteStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamInteStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamInteStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamInteStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamInteStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr SlamInteStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SlamInteStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SlamInteStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamInteStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SlamInteStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamInteStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SlamInteStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SlamInteStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SlamInteStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SlamInteStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* SlamInteStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

SlamInteStatusTypeSupport::_ptr_type SlamInteStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::SlamInteStatus> : MetaStruct {
  typedef SkyworthMsgs::SlamInteStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::SlamInteStatus& typed = *static_cast<const SkyworthMsgs::SlamInteStatus*>(stru);
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    if (std::strcmp(field, "machingDegree") == 0) {
      return typed.machingDegree;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (std::strcmp(field, "machingDegree") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'machingDegree' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'machingDegree' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPointList_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::SlamInteStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    if (std::strcmp(field, "machingDegree") == 0) {
      return make_field_cmp(&T::machingDegree, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"statusType", "status", "machingDegree", "obsData", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    if (std::strcmp(field, "machingDegree") == 0) {
      return &static_cast<const T*>(stru)->machingDegree;
    }
    if (std::strcmp(field, "obsData") == 0) {
      return &static_cast<const T*>(stru)->obsData;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "machingDegree") == 0) {
      static_cast<T*>(lhs)->machingDegree = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "obsData") == 0) {
      SkyworthMsgs::EdgeXyzPointList* lhsArr = &static_cast<T*>(lhs)->obsData;
      const SkyworthMsgs::EdgeXyzPointList* rhsArr = static_cast<const SkyworthMsgs::EdgeXyzPointList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 360; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    if (std::strcmp(field, "machingDegree") == 0) {
      return static_cast<const T*>(lhs)->machingDegree == static_cast<const T*>(rhs)->machingDegree;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamInteStatus>()
{
  static MetaStructImpl<SkyworthMsgs::SlamInteStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamInteStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::SlamInteStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamInteStatus */


/* Begin STRUCT: SlamInteCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamInteCommand& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
  gen_find_size(stru.destPoint, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamInteCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command))
    && (strm << stru.destPoint);
}

bool operator>>(Serializer& strm, SkyworthMsgs::SlamInteCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command))
    && (strm >> stru.destPoint);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamInteCommand& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamInteCommand> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamInteCommand> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamInteCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamInteCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr SlamInteCommandTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SlamInteCommand> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SlamInteCommandTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamInteCommand> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SlamInteCommandTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamInteCommand> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SlamInteCommand, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SlamInteCommandTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SlamInteCommand>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SlamInteCommandTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* SlamInteCommandTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

SlamInteCommandTypeSupport::_ptr_type SlamInteCommandTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::SlamInteCommand> : MetaStruct {
  typedef SkyworthMsgs::SlamInteCommand T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::SlamInteCommand& typed = *static_cast<const SkyworthMsgs::SlamInteCommand*>(stru);
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(&typed.destPoint, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteCommand)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(ser, field + 10);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::DestXyzPoint*>(0))) {
        throw std::runtime_error("Field 'destPoint' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::SlamInteCommand");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return make_struct_cmp(&T::destPoint, getMetaStruct<SkyworthMsgs::DestXyzPoint>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteCommand)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"commandType", "command", "destPoint", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      return &static_cast<const T*>(stru)->destPoint;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteCommand)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      static_cast<T*>(lhs)->destPoint = *static_cast<const SkyworthMsgs::DestXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteCommand)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamInteCommand)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamInteCommand>()
{
  static MetaStructImpl<SkyworthMsgs::SlamInteCommand> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamInteCommand*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::SlamInteCommand>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamInteCommand */


/* Begin STRUCT: PatrolStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.status));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.statusType.in())
    && (strm << ACE_OutputCDR::from_char(stru.status));
}

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.statusType.out())
    && (strm >> ACE_InputCDR::to_char(stru.status));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr PatrolStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PatrolStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr PatrolStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PatrolStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PatrolStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PatrolStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PatrolStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool PatrolStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* PatrolStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

PatrolStatusTypeSupport::_ptr_type PatrolStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::PatrolStatus> : MetaStruct {
  typedef SkyworthMsgs::PatrolStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::PatrolStatus& typed = *static_cast<const SkyworthMsgs::PatrolStatus*>(stru);
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::PatrolStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"statusType", "status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolStatus>()
{
  static MetaStructImpl<SkyworthMsgs::PatrolStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::PatrolStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolStatus */


/* Begin STRUCT: PatrolCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolCommand& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
  gen_find_size(stru.destPoint, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command))
    && (strm << stru.destPoint);
}

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command))
    && (strm >> stru.destPoint);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolCommand& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolCommand> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolCommand> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr PatrolCommandTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PatrolCommand> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr PatrolCommandTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolCommand> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PatrolCommandTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolCommand> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PatrolCommand, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PatrolCommandTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PatrolCommand>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool PatrolCommandTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* PatrolCommandTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

PatrolCommandTypeSupport::_ptr_type PatrolCommandTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::PatrolCommand> : MetaStruct {
  typedef SkyworthMsgs::PatrolCommand T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::PatrolCommand& typed = *static_cast<const SkyworthMsgs::PatrolCommand*>(stru);
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(&typed.destPoint, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolCommand)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(ser, field + 10);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::DestXyzPoint*>(0))) {
        throw std::runtime_error("Field 'destPoint' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::PatrolCommand");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return make_struct_cmp(&T::destPoint, getMetaStruct<SkyworthMsgs::DestXyzPoint>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolCommand)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"commandType", "command", "destPoint", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      return &static_cast<const T*>(stru)->destPoint;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolCommand)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      static_cast<T*>(lhs)->destPoint = *static_cast<const SkyworthMsgs::DestXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolCommand)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolCommand)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolCommand>()
{
  static MetaStructImpl<SkyworthMsgs::PatrolCommand> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolCommand*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::PatrolCommand>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolCommand */


/* Begin STRUCT: CleanStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.status));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.statusType.in())
    && (strm << ACE_OutputCDR::from_char(stru.status));
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.statusType.out())
    && (strm >> ACE_InputCDR::to_char(stru.status));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanStatusTypeSupport::_ptr_type CleanStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanStatus> : MetaStruct {
  typedef SkyworthMsgs::CleanStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanStatus& typed = *static_cast<const SkyworthMsgs::CleanStatus*>(stru);
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"statusType", "status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanStatus>()
{
  static MetaStructImpl<SkyworthMsgs::CleanStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanStatus */


/* Begin STRUCT: CleanCommand */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanCommand& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.distance);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.angle);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command))
    && (strm << stru.distance)
    && (strm << stru.angle);
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanCommand& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command))
    && (strm >> stru.distance)
    && (strm >> stru.angle);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanCommand& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanCommand> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanCommand> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanCommand> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanCommandTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanCommand> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanCommandTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanCommand> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanCommandTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanCommand> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanCommand, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanCommandTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanCommand>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanCommandTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanCommandTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanCommandTypeSupport::_ptr_type CleanCommandTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanCommand> : MetaStruct {
  typedef SkyworthMsgs::CleanCommand T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanCommand& typed = *static_cast<const SkyworthMsgs::CleanCommand*>(stru);
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return typed.distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return typed.angle;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanCommand)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (std::strcmp(field, "distance") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'distance' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'distance' could not be skipped");
      }
    }
    if (std::strcmp(field, "angle") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'angle' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'angle' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanCommand");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    if (std::strcmp(field, "distance") == 0) {
      return make_field_cmp(&T::distance, next);
    }
    if (std::strcmp(field, "angle") == 0) {
      return make_field_cmp(&T::angle, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanCommand)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"commandType", "command", "distance", "angle", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return &static_cast<const T*>(stru)->distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return &static_cast<const T*>(stru)->angle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanCommand)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "distance") == 0) {
      static_cast<T*>(lhs)->distance = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "angle") == 0) {
      static_cast<T*>(lhs)->angle = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanCommand)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return static_cast<const T*>(lhs)->distance == static_cast<const T*>(rhs)->distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return static_cast<const T*>(lhs)->angle == static_cast<const T*>(rhs)->angle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanCommand)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanCommand>()
{
  static MetaStructImpl<SkyworthMsgs::CleanCommand> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanCommand*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanCommand>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanCommand */


/* Begin TYPEDEF: MapPicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::MapPicData_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 230400 * max_marshaled_size_char();
}

bool operator<<(Serializer& strm, const SkyworthMsgs::MapPicData_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_char_array(arr.in(), 230400);
}

bool operator>>(Serializer& strm, SkyworthMsgs::MapPicData_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_char_array(arr.out(), 230400);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, SkyworthMsgs::MapPicData_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(230400), 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: MapPicData */


/* Begin STRUCT: MapLiveData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::MapLiveData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  SkyworthMsgs::MapPicData_forany stru_data(const_cast<SkyworthMsgs::MapPicData_slice*>(stru.data));
  gen_find_size(stru_data, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::MapLiveData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::MapPicData_forany stru_data(const_cast<SkyworthMsgs::MapPicData_slice*>(stru.data));
  return (strm << stru_data);
}

bool operator>>(Serializer& strm, SkyworthMsgs::MapLiveData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  SkyworthMsgs::MapPicData_forany stru_data(const_cast<SkyworthMsgs::MapPicData_slice*>(stru.data));
  return (strm >> stru_data);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::MapLiveData& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 230400;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::MapLiveData> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::MapLiveData> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::MapLiveData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::MapLiveData> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr MapLiveDataTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<MapLiveData> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr MapLiveDataTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<MapLiveData> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr MapLiveDataTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<MapLiveData> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<MapLiveData, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& MapLiveDataTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<MapLiveData>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool MapLiveDataTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* MapLiveDataTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

MapLiveDataTypeSupport::_ptr_type MapLiveDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::MapLiveData> : MetaStruct {
  typedef SkyworthMsgs::MapLiveData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::MapLiveData& typed = *static_cast<const SkyworthMsgs::MapLiveData*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<SkyworthMsgs::MapPicData_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::MapLiveData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "data") == 0) {
      SkyworthMsgs::MapPicData* lhsArr = &static_cast<T*>(lhs)->data;
      const SkyworthMsgs::MapPicData* rhsArr = static_cast<const SkyworthMsgs::MapPicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 230400; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveData)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::MapLiveData>()
{
  static MetaStructImpl<SkyworthMsgs::MapLiveData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::MapLiveData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::MapLiveData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: MapLiveData */


/* Begin STRUCT: SlamManageStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamManageStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.status));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamManageStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.statusType.in())
    && (strm << ACE_OutputCDR::from_char(stru.status));
}

bool operator>>(Serializer& strm, SkyworthMsgs::SlamManageStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.statusType.out())
    && (strm >> ACE_InputCDR::to_char(stru.status));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamManageStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamManageStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamManageStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamManageStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamManageStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr SlamManageStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SlamManageStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SlamManageStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamManageStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SlamManageStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamManageStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SlamManageStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SlamManageStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SlamManageStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SlamManageStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* SlamManageStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

SlamManageStatusTypeSupport::_ptr_type SlamManageStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::SlamManageStatus> : MetaStruct {
  typedef SkyworthMsgs::SlamManageStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::SlamManageStatus& typed = *static_cast<const SkyworthMsgs::SlamManageStatus*>(stru);
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::SlamManageStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"statusType", "status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamManageStatus>()
{
  static MetaStructImpl<SkyworthMsgs::SlamManageStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamManageStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::SlamManageStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamManageStatus */


/* Begin STRUCT: SlamManageCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::SlamManageCmd& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.distance);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.angle);
  gen_find_size(stru.destPoint, size, padding);
}

bool operator<<(Serializer& strm, const SkyworthMsgs::SlamManageCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command))
    && (strm << stru.distance)
    && (strm << stru.angle)
    && (strm << stru.destPoint);
}

bool operator>>(Serializer& strm, SkyworthMsgs::SlamManageCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command))
    && (strm >> stru.distance)
    && (strm >> stru.angle)
    && (strm >> stru.destPoint);
}

size_t gen_max_marshaled_size(const SkyworthMsgs::SlamManageCmd& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::SlamManageCmd> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::SlamManageCmd> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::SlamManageCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::SlamManageCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr SlamManageCmdTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<SlamManageCmd> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SlamManageCmdTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamManageCmd> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SlamManageCmdTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<SlamManageCmd> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SlamManageCmd, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SlamManageCmdTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<SlamManageCmd>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SlamManageCmdTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* SlamManageCmdTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

SlamManageCmdTypeSupport::_ptr_type SlamManageCmdTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::SlamManageCmd> : MetaStruct {
  typedef SkyworthMsgs::SlamManageCmd T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::SlamManageCmd& typed = *static_cast<const SkyworthMsgs::SlamManageCmd*>(stru);
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return typed.distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return typed.angle;
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(&typed.destPoint, field + 10);
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageCmd)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (std::strcmp(field, "distance") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'distance' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'distance' could not be skipped");
      }
    }
    if (std::strcmp(field, "angle") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'angle' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'angle' could not be skipped");
      }
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return getMetaStruct<SkyworthMsgs::DestXyzPoint>().getValue(ser, field + 10);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::DestXyzPoint*>(0))) {
        throw std::runtime_error("Field 'destPoint' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::SlamManageCmd");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    if (std::strcmp(field, "distance") == 0) {
      return make_field_cmp(&T::distance, next);
    }
    if (std::strcmp(field, "angle") == 0) {
      return make_field_cmp(&T::angle, next);
    }
    if (std::strncmp(field, "destPoint.", 10) == 0) {
      return make_struct_cmp(&T::destPoint, getMetaStruct<SkyworthMsgs::DestXyzPoint>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageCmd)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"commandType", "command", "distance", "angle", "destPoint", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return &static_cast<const T*>(stru)->distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return &static_cast<const T*>(stru)->angle;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      return &static_cast<const T*>(stru)->destPoint;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageCmd)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "distance") == 0) {
      static_cast<T*>(lhs)->distance = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "angle") == 0) {
      static_cast<T*>(lhs)->angle = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "destPoint") == 0) {
      static_cast<T*>(lhs)->destPoint = *static_cast<const SkyworthMsgs::DestXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageCmd)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    if (std::strcmp(field, "distance") == 0) {
      return static_cast<const T*>(lhs)->distance == static_cast<const T*>(rhs)->distance;
    }
    if (std::strcmp(field, "angle") == 0) {
      return static_cast<const T*>(lhs)->angle == static_cast<const T*>(rhs)->angle;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::SlamManageCmd)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::SlamManageCmd>()
{
  static MetaStructImpl<SkyworthMsgs::SlamManageCmd> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::SlamManageCmd*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::SlamManageCmd>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SlamManageCmd */


/* Begin STRUCT: PatrolManageStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolManageStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.area.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.status));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolManageStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.area.in())
    && (strm << stru.statusType.in())
    && (strm << ACE_OutputCDR::from_char(stru.status));
}

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolManageStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.area.out())
    && (strm >> stru.statusType.out())
    && (strm >> ACE_InputCDR::to_char(stru.status));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolManageStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolManageStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolManageStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolManageStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolManageStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr PatrolManageStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PatrolManageStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr PatrolManageStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolManageStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PatrolManageStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolManageStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PatrolManageStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PatrolManageStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PatrolManageStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool PatrolManageStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* PatrolManageStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

PatrolManageStatusTypeSupport::_ptr_type PatrolManageStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::PatrolManageStatus> : MetaStruct {
  typedef SkyworthMsgs::PatrolManageStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::PatrolManageStatus& typed = *static_cast<const SkyworthMsgs::PatrolManageStatus*>(stru);
    if (std::strcmp(field, "area") == 0) {
      return typed.area.in();
    }
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "area") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'area' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'area' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'area' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::PatrolManageStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "area") == 0) {
      return make_field_cmp(&T::area, next);
    }
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"area", "statusType", "status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "area") == 0) {
      return &static_cast<const T*>(stru)->area;
    }
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "area") == 0) {
      static_cast<T*>(lhs)->area = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "area") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->area.in(), static_cast<const T*>(rhs)->area.in());
    }
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolManageStatus>()
{
  static MetaStructImpl<SkyworthMsgs::PatrolManageStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolManageStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::PatrolManageStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolManageStatus */


/* Begin STRUCT: PatrolManageCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::PatrolManageCmd& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.area.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::PatrolManageCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.area.in())
    && (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command));
}

bool operator>>(Serializer& strm, SkyworthMsgs::PatrolManageCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.area.out())
    && (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::PatrolManageCmd& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::PatrolManageCmd> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::PatrolManageCmd> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::PatrolManageCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::PatrolManageCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr PatrolManageCmdTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<PatrolManageCmd> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr PatrolManageCmdTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolManageCmd> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr PatrolManageCmdTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<PatrolManageCmd> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PatrolManageCmd, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& PatrolManageCmdTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<PatrolManageCmd>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool PatrolManageCmdTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* PatrolManageCmdTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

PatrolManageCmdTypeSupport::_ptr_type PatrolManageCmdTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::PatrolManageCmd> : MetaStruct {
  typedef SkyworthMsgs::PatrolManageCmd T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::PatrolManageCmd& typed = *static_cast<const SkyworthMsgs::PatrolManageCmd*>(stru);
    if (std::strcmp(field, "area") == 0) {
      return typed.area.in();
    }
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageCmd)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "area") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'area' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'area' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'area' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::PatrolManageCmd");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "area") == 0) {
      return make_field_cmp(&T::area, next);
    }
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageCmd)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"area", "commandType", "command", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "area") == 0) {
      return &static_cast<const T*>(stru)->area;
    }
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageCmd)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "area") == 0) {
      static_cast<T*>(lhs)->area = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageCmd)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "area") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->area.in(), static_cast<const T*>(rhs)->area.in());
    }
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::PatrolManageCmd)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::PatrolManageCmd>()
{
  static MetaStructImpl<SkyworthMsgs::PatrolManageCmd> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::PatrolManageCmd*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::PatrolManageCmd>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PatrolManageCmd */


/* Begin STRUCT: CleanManageStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanManageStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.status));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanManageStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.statusType.in())
    && (strm << ACE_OutputCDR::from_char(stru.status));
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanManageStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.statusType.out())
    && (strm >> ACE_InputCDR::to_char(stru.status));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanManageStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanManageStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanManageStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanManageStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanManageStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanManageStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanManageStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanManageStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanManageStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanManageStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanManageStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanManageStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanManageStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanManageStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanManageStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanManageStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanManageStatusTypeSupport::_ptr_type CleanManageStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanManageStatus> : MetaStruct {
  typedef SkyworthMsgs::CleanManageStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanManageStatus& typed = *static_cast<const SkyworthMsgs::CleanManageStatus*>(stru);
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanManageStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"statusType", "status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanManageStatus>()
{
  static MetaStructImpl<SkyworthMsgs::CleanManageStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanManageStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanManageStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanManageStatus */


/* Begin STRUCT: CleanManageCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanManageCmd& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.point1, size, padding);
  gen_find_size(stru.point2, size, padding);
  gen_find_size(stru.point3, size, padding);
  gen_find_size(stru.point4, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanManageCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.point1)
    && (strm << stru.point2)
    && (strm << stru.point3)
    && (strm << stru.point4)
    && (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command));
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanManageCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.point1)
    && (strm >> stru.point2)
    && (strm >> stru.point3)
    && (strm >> stru.point4)
    && (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanManageCmd& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanManageCmd> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanManageCmd> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanManageCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanManageCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanManageCmdTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanManageCmd> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanManageCmdTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanManageCmd> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanManageCmdTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanManageCmd> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanManageCmd, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanManageCmdTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanManageCmd>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanManageCmdTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanManageCmdTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanManageCmdTypeSupport::_ptr_type CleanManageCmdTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanManageCmd> : MetaStruct {
  typedef SkyworthMsgs::CleanManageCmd T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanManageCmd& typed = *static_cast<const SkyworthMsgs::CleanManageCmd*>(stru);
    if (std::strncmp(field, "point1.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point1, field + 7);
    }
    if (std::strncmp(field, "point2.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point2, field + 7);
    }
    if (std::strncmp(field, "point3.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point3, field + 7);
    }
    if (std::strncmp(field, "point4.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point4, field + 7);
    }
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageCmd)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "point1.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point1' could not be skipped");
      }
    }
    if (std::strncmp(field, "point2.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point2' could not be skipped");
      }
    }
    if (std::strncmp(field, "point3.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point3' could not be skipped");
      }
    }
    if (std::strncmp(field, "point4.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point4' could not be skipped");
      }
    }
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanManageCmd");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "point1.", 7) == 0) {
      return make_struct_cmp(&T::point1, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "point2.", 7) == 0) {
      return make_struct_cmp(&T::point2, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "point3.", 7) == 0) {
      return make_struct_cmp(&T::point3, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "point4.", 7) == 0) {
      return make_struct_cmp(&T::point4, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageCmd)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"point1", "point2", "point3", "point4", "commandType", "command", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "point1") == 0) {
      return &static_cast<const T*>(stru)->point1;
    }
    if (std::strcmp(field, "point2") == 0) {
      return &static_cast<const T*>(stru)->point2;
    }
    if (std::strcmp(field, "point3") == 0) {
      return &static_cast<const T*>(stru)->point3;
    }
    if (std::strcmp(field, "point4") == 0) {
      return &static_cast<const T*>(stru)->point4;
    }
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageCmd)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "point1") == 0) {
      static_cast<T*>(lhs)->point1 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "point2") == 0) {
      static_cast<T*>(lhs)->point2 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "point3") == 0) {
      static_cast<T*>(lhs)->point3 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "point4") == 0) {
      static_cast<T*>(lhs)->point4 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageCmd)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanManageCmd)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanManageCmd>()
{
  static MetaStructImpl<SkyworthMsgs::CleanManageCmd> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanManageCmd*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanManageCmd>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanManageCmd */


/* Begin STRUCT: MapLiveCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::MapLiveCmd& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::MapLiveCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command));
}

bool operator>>(Serializer& strm, SkyworthMsgs::MapLiveCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::MapLiveCmd& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::MapLiveCmd> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::MapLiveCmd> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::MapLiveCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::MapLiveCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr MapLiveCmdTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<MapLiveCmd> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr MapLiveCmdTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<MapLiveCmd> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr MapLiveCmdTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<MapLiveCmd> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<MapLiveCmd, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& MapLiveCmdTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<MapLiveCmd>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool MapLiveCmdTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* MapLiveCmdTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

MapLiveCmdTypeSupport::_ptr_type MapLiveCmdTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::MapLiveCmd> : MetaStruct {
  typedef SkyworthMsgs::MapLiveCmd T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::MapLiveCmd& typed = *static_cast<const SkyworthMsgs::MapLiveCmd*>(stru);
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveCmd)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::MapLiveCmd");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveCmd)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"commandType", "command", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveCmd)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveCmd)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::MapLiveCmd)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::MapLiveCmd>()
{
  static MetaStructImpl<SkyworthMsgs::MapLiveCmd> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::MapLiveCmd*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::MapLiveCmd>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: MapLiveCmd */


/* Begin STRUCT: CleanRouterStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanRouterStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.statusType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.status));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanRouterStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.statusType.in())
    && (strm << ACE_OutputCDR::from_char(stru.status));
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanRouterStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.statusType.out())
    && (strm >> ACE_InputCDR::to_char(stru.status));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanRouterStatus& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanRouterStatus> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanRouterStatus> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanRouterStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanRouterStatus> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanRouterStatusTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanRouterStatus> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanRouterStatusTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanRouterStatus> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanRouterStatusTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanRouterStatus> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanRouterStatus, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanRouterStatusTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanRouterStatus>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanRouterStatusTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanRouterStatusTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanRouterStatusTypeSupport::_ptr_type CleanRouterStatusTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanRouterStatus> : MetaStruct {
  typedef SkyworthMsgs::CleanRouterStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanRouterStatus& typed = *static_cast<const SkyworthMsgs::CleanRouterStatus*>(stru);
    if (std::strcmp(field, "statusType") == 0) {
      return typed.statusType.in();
    }
    if (std::strcmp(field, "status") == 0) {
      return typed.status;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'statusType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'statusType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'statusType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "status") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'status' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'status' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanRouterStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "statusType") == 0) {
      return make_field_cmp(&T::statusType, next);
    }
    if (std::strcmp(field, "status") == 0) {
      return make_field_cmp(&T::status, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"statusType", "status", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "statusType") == 0) {
      return &static_cast<const T*>(stru)->statusType;
    }
    if (std::strcmp(field, "status") == 0) {
      return &static_cast<const T*>(stru)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "statusType") == 0) {
      static_cast<T*>(lhs)->statusType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "status") == 0) {
      static_cast<T*>(lhs)->status = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "statusType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->statusType.in(), static_cast<const T*>(rhs)->statusType.in());
    }
    if (std::strcmp(field, "status") == 0) {
      return static_cast<const T*>(lhs)->status == static_cast<const T*>(rhs)->status;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanRouterStatus>()
{
  static MetaStructImpl<SkyworthMsgs::CleanRouterStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanRouterStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanRouterStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanRouterStatus */


/* Begin STRUCT: CleanRouterCmd */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const SkyworthMsgs::CleanRouterCmd& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.point1, size, padding);
  gen_find_size(stru.point2, size, padding);
  gen_find_size(stru.point3, size, padding);
  gen_find_size(stru.point4, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.area.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.commandType.in()) + 1;
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.command));
}

bool operator<<(Serializer& strm, const SkyworthMsgs::CleanRouterCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.point1)
    && (strm << stru.point2)
    && (strm << stru.point3)
    && (strm << stru.point4)
    && (strm << stru.area.in())
    && (strm << stru.commandType.in())
    && (strm << ACE_OutputCDR::from_char(stru.command));
}

bool operator>>(Serializer& strm, SkyworthMsgs::CleanRouterCmd& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.point1)
    && (strm >> stru.point2)
    && (strm >> stru.point3)
    && (strm >> stru.point4)
    && (strm >> stru.area.out())
    && (strm >> stru.commandType.out())
    && (strm >> ACE_InputCDR::to_char(stru.command));
}

size_t gen_max_marshaled_size(const SkyworthMsgs::CleanRouterCmd& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const SkyworthMsgs::CleanRouterCmd> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const SkyworthMsgs::CleanRouterCmd> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const SkyworthMsgs::CleanRouterCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<SkyworthMsgs::CleanRouterCmd> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace SkyworthMsgs {
::DDS::DataWriter_ptr CleanRouterCmdTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<CleanRouterCmd> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr CleanRouterCmdTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanRouterCmd> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr CleanRouterCmdTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<CleanRouterCmd> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<CleanRouterCmd, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& CleanRouterCmdTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<CleanRouterCmd>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool CleanRouterCmdTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* CleanRouterCmdTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

CleanRouterCmdTypeSupport::_ptr_type CleanRouterCmdTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<SkyworthMsgs::CleanRouterCmd> : MetaStruct {
  typedef SkyworthMsgs::CleanRouterCmd T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  Value getValue(const void* stru, const char* field) const
  {
    const SkyworthMsgs::CleanRouterCmd& typed = *static_cast<const SkyworthMsgs::CleanRouterCmd*>(stru);
    if (std::strncmp(field, "point1.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point1, field + 7);
    }
    if (std::strncmp(field, "point2.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point2, field + 7);
    }
    if (std::strncmp(field, "point3.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point3, field + 7);
    }
    if (std::strncmp(field, "point4.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(&typed.point4, field + 7);
    }
    if (std::strcmp(field, "area") == 0) {
      return typed.area.in();
    }
    if (std::strcmp(field, "commandType") == 0) {
      return typed.commandType.in();
    }
    if (std::strcmp(field, "command") == 0) {
      return typed.command;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterCmd)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "point1.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point1' could not be skipped");
      }
    }
    if (std::strncmp(field, "point2.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point2' could not be skipped");
      }
    }
    if (std::strncmp(field, "point3.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point3' could not be skipped");
      }
    }
    if (std::strncmp(field, "point4.", 7) == 0) {
      return getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<SkyworthMsgs::EdgeXyzPoint*>(0))) {
        throw std::runtime_error("Field 'point4' could not be skipped");
      }
    }
    if (std::strcmp(field, "area") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'area' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'area' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'area' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "commandType") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'commandType' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'commandType' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'commandType' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "command") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'command' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'command' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct SkyworthMsgs::CleanRouterCmd");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "point1.", 7) == 0) {
      return make_struct_cmp(&T::point1, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "point2.", 7) == 0) {
      return make_struct_cmp(&T::point2, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "point3.", 7) == 0) {
      return make_struct_cmp(&T::point3, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "point4.", 7) == 0) {
      return make_struct_cmp(&T::point4, getMetaStruct<SkyworthMsgs::EdgeXyzPoint>().create_qc_comparator(field + 7), next);
    }
    if (std::strcmp(field, "area") == 0) {
      return make_field_cmp(&T::area, next);
    }
    if (std::strcmp(field, "commandType") == 0) {
      return make_field_cmp(&T::commandType, next);
    }
    if (std::strcmp(field, "command") == 0) {
      return make_field_cmp(&T::command, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterCmd)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"point1", "point2", "point3", "point4", "area", "commandType", "command", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "point1") == 0) {
      return &static_cast<const T*>(stru)->point1;
    }
    if (std::strcmp(field, "point2") == 0) {
      return &static_cast<const T*>(stru)->point2;
    }
    if (std::strcmp(field, "point3") == 0) {
      return &static_cast<const T*>(stru)->point3;
    }
    if (std::strcmp(field, "point4") == 0) {
      return &static_cast<const T*>(stru)->point4;
    }
    if (std::strcmp(field, "area") == 0) {
      return &static_cast<const T*>(stru)->area;
    }
    if (std::strcmp(field, "commandType") == 0) {
      return &static_cast<const T*>(stru)->commandType;
    }
    if (std::strcmp(field, "command") == 0) {
      return &static_cast<const T*>(stru)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterCmd)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "point1") == 0) {
      static_cast<T*>(lhs)->point1 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "point2") == 0) {
      static_cast<T*>(lhs)->point2 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "point3") == 0) {
      static_cast<T*>(lhs)->point3 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "point4") == 0) {
      static_cast<T*>(lhs)->point4 = *static_cast<const SkyworthMsgs::EdgeXyzPoint*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "area") == 0) {
      static_cast<T*>(lhs)->area = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "commandType") == 0) {
      static_cast<T*>(lhs)->commandType = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "command") == 0) {
      static_cast<T*>(lhs)->command = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterCmd)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "area") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->area.in(), static_cast<const T*>(rhs)->area.in());
    }
    if (std::strcmp(field, "commandType") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->commandType.in(), static_cast<const T*>(rhs)->commandType.in());
    }
    if (std::strcmp(field, "command") == 0) {
      return static_cast<const T*>(lhs)->command == static_cast<const T*>(rhs)->command;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct SkyworthMsgs::CleanRouterCmd)");
  }
};

template<>
const MetaStruct& getMetaStruct<SkyworthMsgs::CleanRouterCmd>()
{
  static MetaStructImpl<SkyworthMsgs::CleanRouterCmd> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, SkyworthMsgs::CleanRouterCmd*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<SkyworthMsgs::CleanRouterCmd>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: CleanRouterCmd */

/* End MODULE: SkyworthMsgs */
